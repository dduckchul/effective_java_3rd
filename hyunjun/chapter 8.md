# 8장 메서드
## Item 49. 매개변수가 유효한지 검사하라
> * 프로그래밍 일반 원칙 : 오류는 가능한 빨리 (발생한 곳에서) 잡아야 한다  
> * public, protected 메서드는 매개변수가 잘못되엇을때 던지는 예외를 문서화 해야한다
   ex> @throws IlegalArgumentException m 이 0보다 작으면 발생한다.   
> * 자바 7에 java.util.Object.requiredNonNull 메서드로 null 검사를 변하게 할 수 있음.
    자바 9에는 범위 검사 메소드도 추가 됨. (checkFromIndexSize, checkFromToIndex, checkIndex)
   ex> Objects.requiredNonNull(strategy, "전략");   
> * Assertion : 단언문 - 조건이 무조건 참이라고 선언하는것. 참이 아니면 AssertError 던짐
    runtime에는 아무 효과도 없다? 검증 필요. 런타임 아니면 확인을 못하는 조건이 있어보임
    > ex> assert a!= null; assert offset >= 0 && offset <= a.length
> * 프로그래밍 일반 원칙 : 메서드가 직접 사용하지는 않으나 나중에 사용하러 저장하는 매개변수는 더 꼼꼼히 검사해야함
    예외가 문제가있는 코드와 멀리 떨어져서 발생하기 때문에 추적하기 어려워진다.
    > ex> [] -> List 로 변환하는 메서드의 경우 [] != null을 검사하지 않으면 나중에 List를 사용할떄 예외가 발생함  
> * 프로그래밍 일반 원칙 : 메서드 몸체가 실행되기 전에 매개변수를 검사하라
> * 예외 : 유효성 검사 비용이 지나치게 크거나, 계산 과정중 암묵적으로 검사가 될때(ex> 비교메소드는 비교할때 대상의 타입을 암묵적으로 검사하게됨)

## Item 50. 적시에 방어적 복사본을 만들라
> * Date는 사용하면 안됨 java8에 LocalDate, LocalTime, LocalDateTime 사용해야됨
> * 생성자에서 매개변수로 객체를 받는 경우에는 사용자가 참조를 가지고 있으므로 원복객체가 변경될 위험이 있다.
    따라서 생성자에서 매개변수를 받은뒤 복사해서 저장해야 안전하다.
    ex>  
    <code> 
         Period(Date start, Date end) {
                 this.start = new Date(start.getTime()); this.end = new Date(end.getTime());
                  if (this.start.compare(this.end) > 0)  {
                     throw Exception("시작일이 종료일보다 큽니다.")
                  }
            }
   </code>
> * 복사후에 검증을 하는 이유는 멀티 스레드 환경에서 검사후 복사하기전에 값이 바뀔수 있으므로
    또한 clone으로 복사하면 안됨 Date를 상속한 하위 클래스가 clone을 악으적으로 수정할 수 있기 때문에
> * 접근자에서도 복사본을 리턴해줘라
    ex>  
    <code>
        public Date getStatDate() {
                  return new Date(this.start.getTime());
         }
   </code>
   접근자에서는 clone을 사용해도 된다. 내가 가지고있는 객체가 Date임이 확실하기 때문에
> * 객체의 참조를 내부의 자료구조에 저장하는 경우에는 객체의 값이 변경 됬을때 클래스가 정상적으로 동작할지 생각해 봐야 한다.
    만약 그게 아니라면 복사본을 리턴해줘야 함
    ex> 배열의 경우는 가변이므로 복사본을 리턴하던지 불변 배열을 만들어 리턴해야됨
> * 되도록 불변 객처를 조합해야만 방어적 복사를 할 일이 줄어든다.

## Item 51. 메서드 시그니처를 신중희 설계하라
> * 메서드 이름을 신중히 짓자 : 표준명명규칙을 따르고, 긴 이름이 피해라
> * 편의 메서드를 너무 많이 만들지 말자 : 자신의 기능을 완벽히 구현하는 메서드를 제공하고, 아주 자주 쓰이는 경우에만 약칭 메서드를 둬라. ????
> * 매개변수 목록은 짧게 유지해라 : 매개변수를 4개 이하로 유지하고, 같은 타입의 매개변수가 연달아 나오는 것은 조심하자.
#### 매개변수를 줄여주는 테크닉
> * 1. 여러 메서드로 쪼개라 : 하나의 매서드를 기능 별로 쪼개서 원래의 매개변수의 부분 집합을 받게 하라
    ex> 배열의 특정구간에서 값을 찾는 메서드의 경우 시작, 끝, 값 세개의 매개변수가 필요하지만
        이를 subList, find 두개로 쪼개면 매개변수를 각각 2개 1개로 줄일수 있다.
> * 이를 직교성을 높인다고 하는데 공통점이 없는 기능들을 잘 분리햇다 정도로 해석 가능하다.
     시스템 차원에서보면 마이크로 서비스는 직교성이 높다고 볼 수 있고 모놀리틱은 직교성이 낮다고 볼 수 있다.
> * 2. 매개변수를 묶어주는 도우미 클래스를 만들어라
    매개변수 여러개를 하나의 개념으로 볼수있다면 이를 묶어주는 도우미 클래스를 만들어라
    일반적으로 이런 클래스는 정적 멤버 클래스로 만든다.
    ex> 카드게임 클래스를 만든다고 하면 숫자와 무늬를 하나의 개념으로 볼수있으므로 이를 묶는 클래스를 만들면 좋다.
>* 3. 빌더 패턴을 매서드 호출에 응용한 것
      - 모든 매개변수를 추상화한 객체를 정의하고 클라이언트에서 필요한 매개변수만 setter로 설정한다음 excute 메소드를 호출해 유효성을 검사함
        그 이후에 설정이 완료된 객체를 넘김
   매개변수의 타입으로는 클래스보다 인터페이스가 낫다.
   또한 boolean 값보다 원소가 두개인 Enum이 더 낫다.
     ex> 온도 클래스에서 섭시 화씨를 지원한다면 newInstance(true)보다 newInstance(Enum.섭씨)가 더 알아보기 쉽고 소스 리팩토링도 가능함
     
## Item 52. 다중정의는 신중히 사용하라
> * 다중정의(Overloading)는 컴파일 타임에 어떤 매소드가 실행될지 정해짐
    다시 말해서 다중정의는 정적으로 동작하고 재정의(Overriding)는 동적으로 동작함
> * 다중정의를 함부로 사용하면 혼동을 줄 수 있어 조심해야 된다
    혼란을 막는 보수적인 방법은 매개변수 갯수가 같은 다중정의는 하지말고
    가변인수를 받는 메서드는 아예 다중정의를 하면 안된다.
    다중정의가 필요하다면 이름을 다르게 지어주는 것도 고려해보라
     ex> readInt, readLong...     
> * 생성자는 다중정의가 불가피하다.
    따라서 다중정의를 피하기 위해서는 1.정적팩터리 메서드 패턴을 도입하거나
    다중정의르 하더라도 매개변수들이 근본적으로 다르게 설계 해야 된다.
> * 근본적으로 다르다는 뜻은 두 타입의 값을 서로 어느쪽으로도 형변환 할수 없다는 뜻이다. ex> String, Trowable  같이 상/하위 관계가 아닌것
> * 다중정의를 하더라도 다중정의된 메소드가 완전히 똑같은 일을 한다면 걱정할 필요가 없다
    이렇게 구현하는 방법은 특수한 메소드에서 일반적인 메소드를 호출하는 것이다
    ex> contentEqual(charSequence cs); -- charSequence는 인터페이스로 구현체로는 StringBuffer, StringBuilder등
        contentEqual는(StrungBuffer), contentEqual는(StrungBuilder)등이 있지만
        모두 return contentEqual(charSequence cs); 식으로 같은 동작을 하므로 다중정의를 걱정 할 필요가 없다.

# Item 53. 가번인수정의는 신중히 사용하라
> * 가변인수 메소드는 매개변수의 유효성 검사를 명시적으로 해야하고 가변인수 사용시 매번 배열을 생성해 할당해야 되는 성능 문제도 있다.
> * 이를 해결하기 위해서는 꼭 필요한 변수는 앞에 따로 선언하고
    ex> sum(int... args) -> sum(int a, int.. resArgs) 이런식이면 꼭 param 하나는 꼭 넣어야 컴파일됨
> * 자주 호출되는 인수의 갯수는 미리 정의 해놓자
    ex> sum함수는 인수가 2개까지일때 호출의 90% 이상이라면
         sum(int a), sum(int a, int b), sum(int... args)
       위와 같이 2개까지는 미리 선언하고 나머지 조금 사용되는걸 가변인수 메소드로 처리하도록 하자

# Item 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라
> * null을 반환하면 사용하는 코드에서도 null을 위한 처리가 필요하고
    반환하는 API에서도 null을 위한 분기문이 필요하기 때문에 null을 넘기면 안된다
> * 또한 null을 넘긴다고 성능이 좋아지는것이 아니기 때문에 null을 넘겨서 얻을 이득이 없다.
> * List.toArray 메소드 T[] = List.toArray(T[] a)
    만들어질 array의 최소 길이가 param으로 넘어간 배열의 길이 됨 (최대는 List 길이만큼)
    
# Item 55. 옵셔널 반환은 신중히 하라
> * 값을 반환하지 못할 가능성이 있고 매번 null을 확인해야 한다면 Optional 반환을 생각해볼 수 있다.
> * 하지만 Optional 반환에는 성능저하가 뒤따르니 성능에 민감한 메소드라면 null이나 예외를 던져라
> * 또한 Optional을 반환값 이외에 용도로 사용하는 경우는 매우 드물므로 사용을 자제하라
> * BizMsgException을 던지는것일 지양해야 할거같음 비검사 예외라 사용하는 쪽에서 모름

# Item 56. 공개된 API요소에는 항상 문서화 주석을 작성해라
> *

