# 8장 메서드
## Item 49. 매개변수가 유효한지 검사하라
> * 프로그래밍 일반 원칙 : 오류는 가능한 빨리 (발생한 곳에서) 잡아야 한다  
> * public, protected 메서드는 매개변수가 잘못되엇을때 던지는 예외를 문서화 해야한다
   ex> @throws IlegalArgumentException m 이 0보다 작으면 발생한다.   
> * 자바 7에 java.util.Object.requiredNonNull 메서드로 null 검사를 변하게 할 수 있음.
    자바 9에는 범위 검사 메소드도 추가 됨. (checkFromIndexSize, checkFromToIndex, checkIndex)
   ex> Objects.requiredNonNull(strategy, "전략");   
> * Assertion : 단언문 - 조건이 무조건 참이라고 선언하는것. 참이 아니면 AssertError 던짐
    runtime에는 아무 효과도 없다? 검증 필요. 런타임 아니면 확인을 못하는 조건이 있어보임
    > ex> assert a!= null; assert offset >= 0 && offset <= a.length
> * 프로그래밍 일반 원칙 : 메서드가 직접 사용하지는 않으나 나중에 사용하러 저장하는 매개변수는 더 꼼꼼히 검사해야함
    예외가 문제가있는 코드와 멀리 떨어져서 발생하기 때문에 추적하기 어려워진다.
    > ex> [] -> List 로 변환하는 메서드의 경우 [] != null을 검사하지 않으면 나중에 List를 사용할떄 예외가 발생함  
> * 프로그래밍 일반 원칙 : 메서드 몸체가 실행되기 전에 매개변수를 검사하라
> * 예외 : 유효성 검사 비용이 지나치게 크거나, 계산 과정중 암묵적으로 검사가 될때(ex> 비교메소드는 비교할때 대상의 타입을 암묵적으로 검사하게됨)

## Item 50. 적시에 방어적 복사본을 만들라
> * Date는 사용하면 안됨 java8에 LocalDate, LocalTime, LocalDateTime 사용해야됨
> * 생성자에서 매개변수로 객체를 받는 경우에는 사용자가 참조를 가지고 있으므로 원복객체가 변경될 위험이 있다.
    따라서 생성자에서 매개변수를 받은뒤 복사해서 저장해야 안전하다.
    ex>  
    <code> 
         Period(Date start, Date end) {
                 this.start = new Date(start.getTime()); this.end = new Date(end.getTime());
                  if (this.start.compare(this.end) > 0)  {
                     throw Exception("시작일이 종료일보다 큽니다.")
                  }
            }
   </code>
> * 복사후에 검증을 하는 이유는 멀티 스레드 환경에서 검사후 복사하기전에 값이 바뀔수 있으므로
    또한 clone으로 복사하면 안됨 Date를 상속한 하위 클래스가 clone을 악으적으로 수정할 수 있기 때문에
> * 접근자에서도 복사본을 리턴해줘라
    ex>  
    <code>
        public Date getStatDate() {
                  return new Date(this.start.getTime());
         }
   </code>
   접근자에서는 clone을 사용해도 된다. 내가 가지고있는 객체가 Date임이 확실하기 때문에
> * 객체의 참조를 내부의 자료구조에 저장하는 경우에는 객체의 값이 변경 됬을때 클래스가 정상적으로 동작할지 생각해 봐야 한다.
    만약 그게 아니라면 복사본을 리턴해줘야 함
    ex> 배열의 경우는 가변이므로 복사본을 리턴하던지 불변 배열을 만들어 리턴해야됨
> * 되도록 불변 객처를 조합해야만 방어적 복사를 할 일이 줄어든다.

## Item 51. 메서드 시그니처를 신중희 설계하라
> * 메서드 이름을 신중히 짓자 : 표준명명규칙을 따르고, 긴 이름이 피해라
> * 편의 메서드를 너무 많이 만들지 말자 : 자신의 기능을 완벽히 구현하는 메서드를 제공하고, 아주 자주 쓰이는 경우에만 약칭 메서드를 둬라. ????
> * 매개변수 목록은 짧게 유지해라 : 매개변수를 4개 이하로 유지하고, 같은 타입의 매개변수가 연달아 나오는 것은 조심하자.
#### 매개변수를 줄여주는 테크닉
> * 1. 여러 메서드로 쪼개라 : 하나의 매서드를 기능 별로 쪼개서 원래의 매개변수의 부분 집합을 받게 하라
    ex> 배열의 특정구간에서 값을 찾는 메서드의 경우 시작, 끝, 값 세개의 매개변수가 필요하지만
        이를 subList, find 두개로 쪼개면 매개변수를 각각 2개 1개로 줄일수 있다.
> * 이를 직교성을 높인다고 하는데 공통점이 없는 기능들을 잘 분리햇다 정도로 해석 가능하다.
     시스템 차원에서보면 마이크로 서비스는 직교성이 높다고 볼 수 있고 모놀리틱은 직교성이 낮다고 볼 수 있다.
> * 2. 매개변수를 묶어주는 도우미 클래스를 만들어라
    매개변수 여러개를 하나의 개념으로 볼수있다면 이를 묶어주는 도우미 클래스를 만들어라
    일반적으로 이런 클래스는 정적 멤버 클래스로 만든다.
    ex> 카드게임 클래스를 만든다고 하면 숫자와 무늬를 하나의 개념으로 볼수있으므로 이를 묶는 클래스를 만들면 좋다.
>* 3. 빌더 패턴을 매서드 호출에 응용한 것
      - 모든 매개변수를 추상화한 객체를 정의하고 클라이언트에서 필요한 매개변수만 setter로 설정한다음 excute 메소드를 호출해 유효성을 검사함
        그 이후에 설정이 완료된 객체를 넘김
   매개변수의 타입으로는 클래스보다 인터페이스가 낫다.
   또한 boolean 값보다 원소가 두개인 Enum이 더 낫다.
     ex> 온도 클래스에서 섭시 화씨를 지원한다면 newInstance(true)보다 newInstance(Enum.섭씨)가 더 알아보기 쉽고 소스 리팩토링도 가능함
