# 4장 클래스와 인터페이스

## Item 15. 클래스와 멤버의 접근 권한을 최소화하라
### 외부에서 접근할 필요가 없다면 package-private로 선언해라 public으로 선언한다면 호환성 유지를 위해 관리가 필요함
### 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
### 공개할 API를 결정한후 나머지를 모두 private, package-private로 선언하여야 한다. protected도 공개 API의 일종임으로 관리가 필요하다
### public 클래스의 필드는 public이 아니어야 한다.
#### 필드를 public으로 두면 필드에 담을 값을 제한할 수 없게 되고 스레드에도 안전하지 않게된다.
#### 리팩토링시에도 public필드를 수정하는 방식으로는 진행할 수 없게된다.
### static final 필드라도 참조주소는 수정못하지만 객체는 수정가능하므로 값이 변경될수 있음

## Item 16. public 클래스에서는 public필드가 아닌 접근자 메서드를 사용하라
### pubilc클래스에서 필드를 public으로 선언하면 공개API가 되므로 내부 표현방식을 맘대로 수정할 수없다.
### package-private, private 중첩클래스에서는 필드를 노출한다 하여도 문제가 없다.

## Item 17. 변경가능성을 최소화하라
### 불변클래스란 객체생성후에는 정보가 바뀌지 않는 클래스. String, 기본타입 Boxing클래스, BigDecimal등
### 불변클래스를 만드는 5가지 원칙
### 1. 객체의 상태를 변경하는 메서드를 만들지 않는다.
### 2. 클래스를 확장할수 없도록 한다.
#### 부주의하게 객체의 상태를 변경하는 것을 막아줌
#### 상속을 막는 대표적 방법은 private클래스로 선언하는것이지만
#### 생성자를 pvivate로 선언하고 public 팩터리 매서드를 만드는것이 더 좋다.
### 3. 모든필드를 final로 선언한다.
#### 시스템이 강제하는 수단으로 설계자의 의도를 드러낼수있다.
#### 인스턴스를 동기화 없이 다른 스레드로 넘겨도 문제가 생기지 않는다.
#### 성능을 위해서 아래와 같이 완화 할 수 있다.
#### 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다. (계산 비용이 큰값을 나중에 계산하여 필드에 저장할수있음)
### 4. 모든필드를 private로 선언한다.
#### 외부에서 필드를 접근해 수정하는 일을 막아준다
#### public final로 선언해도 불변 객체가 되지만 호환성때문에 필드를 수정할수없는 문제가 생긴다.
### 5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
#### 클래스에 가변객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그객체의 참조를 얻을수 없도록 해야한다.
#### 이런 필드는 접근자 메서드가 그 필드를 그대로 반환해서는 안된다.
### 불변객체의 단점
#### 불변객체가 가질수 있는 값이 가짓수가 많다면 이들을 모두 만드는데 큰비용이 들어간다
#### 따라서 불변객체를 완성하는데 도움을 주는 가변 동반클래스를 만들면 좋다(ex) String클래스와, StringBuilder클래스)

## Item 18. 상속보다는 컴포지션을 사용하라
### 상속은 캡슐화를 깨트린다.
#### 상속은 같은 프로그래머가 통제하는 패키지 안이라면 안전하지만.
#### 그렇지 않다면 상위 클래스의 구현변경으로 하위 클래스에 오류가 발생할수 있다.
### 상속대신 컴포지션을 사용하라
#### 기존 클래스에 private 필드를 만들어 기존클래스의 객체를 참조하게 하라
#### 새로운 클래스에는 기존 클래스 메서드에 대응하는 전달메서드를 만들라.
#### 이방식을 사용하면 상위 클래스 내부 구현에서 벗어나 유연한 코드를 만들수있다.
#### 이러한 새클래스를 기존 클래스를 감싸고 있다는 의미에서 Wrapper 클래스라한다.
#### 컴포지션을 이용하면 상위클래스의 결함이 전파되는것도 막을수있다.
#### 래퍼클래스의 단점은 콜백과 어울리지 않는다는것이다
#### 기존클래스에서 래퍼의 존재를 모르니 콜백으로 기존 클래스를 넘겨주어 오류가 발생할수있다 (SELF 문제)
### 상속은 하위클래스와 상위클래스가 is-a 관계인 상황에서만 사용하여야 한다.

## Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
### implementation Requirements로 시작하는 절에 상속할때 중요한 내부 동작방식을 적어놓아라 (@implSpec을 붙이면 자바독이 생성해줌)
### 클래스 내부 동작 과정에 끼어들수 잇는 HOOK을 메소드 형태로 제공해도 된다.
### 상속용 클래스의 생성자는 재정의 가능 메소드를 호출하면 안된다
#### 상위클래스의 생성자가 먼저 실행되므로 하위클래스의 생성자가 실행되기전에 재정의 메소드를 호출할 수 있기 때문
### clone, readObject도 재정의 메소드를 호출해서는 안된다
#### 객체의 복사(직렬화)가 끝나기전에 재정의 메소드가 호출 될 가능성이 있기 때문에
