### Item 69. 예외는 진짜 예외 상황에만 사용하라.
예외는 오직 진짜 예외 상황에서만 써야 하며, 일상적인 제어 흐름용으로 사용해서는 안된다.
잘 설계된 API라면 클라이언트가 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

### Item 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 오류를 사용하라.
호출하는 쪽에서 복구하리라 여겨지는 상황은 검사 예외를 사용한다. 호출자가 catch로 처리하거나..
런타임에러는 보통 "전제조건"을 만족하지 않았을 때 일어난다. API의 명세를 지키지 않았을 때.
Error 클래스를 상속해서 하위 클래스를 만드는 일은 자제하라. 모든 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
검사예외라면 복구를 위해 필요한 정보를 알려주는 메서드도 제공하라.

### Item 71. 필요없는 검사 예외 사용은 피하라.
검사는 프로그램의 안전성을 높여주지만 남용하면 힘들다.
복구가 가능하고 호출자가 처리

### Item 72. 표준 예외를 사용하라.
IllegalArgumentException 허용하지 않은 값이 인수로 건내졌을 때.
Exception, RuntimeException, Throwable, Error 는 직접 사용 금지.

### Item 73. 추상화 수준에 맞는 예외를 던져라.
메서드가 저수준 레벨의 예외를 처리하지 않고 바깥으로 던지면 수행하려는 것과 관련없는 예외가 나타날 수 있다
상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.
예외 번역을 사용하라.
가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선
아래 계층에서 예외를 피할 수 없다면 상위계층에서 처리하여 API호출자에게 까지 전파되지 않도록 해야함

### Item 74. 메서드가 던지는 모든 예외를 문서화하라
@throws를 사용

### Item 76. 가능한 실패 원자적으로 만들라.
호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.

