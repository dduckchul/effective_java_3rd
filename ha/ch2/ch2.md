
# 객체 생성과 파괴
객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 법  
올바른 객체 생성 방법과 불필요한 생성을 피하는 방법  
제 때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령  

## ITEM1 생성자 대신 정적 팩터리 메서드를 고려하라
static factory method : 그 클래스의 인스턴스를 반환하는 단순한 static method  
* 장점
 * 생성자와는 달리 메서드 이름을 가질 수 있다. 객체의 특성을 제대로 설명할 수 있다.
 * 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불필요한 객체 생성을 피할 수 있다. 생성비용이 큰 객체가 자주 요청되는 상황이라면 성능이 좋아진다.
 * 반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. (? 다시읽자)
 * 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. (위에랑 똑같은소리 아닌가)
 * 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 
* 단점
 * 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
 * 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. API문서를 잘 써놓고 메서드 이름도 규약을 따라 지어라
 
## ITEM2 생성자에 매개변수가 많다면 빌더를 고려하라
정적 팩터리 메서드와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점이다.  
이럴 때 Builder pattern 을 이용하자.  
클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수 만으로 생성자를 호출해 빌더 객체를 얻는다. 그런다음 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정한다. 마지막으로 build 메서드를 호출해 객체를 얻는다.   
빌더와 세터 메서드들은 빌더 자신을 반환하기 때문에 method chaning 방식으로 호출 될 수 있다.  
ex) NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).build();  
빌더 패턴의 단점은, 빌더 생성비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다. 코드가 장황해져서 매개변수가 4개 이상은 되어야 값어치를 한다.

## ITEM3 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴(Singleton)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.  
싱글턴을 만드는 방식은 보통 두가지가 있다.  
생성자를 private로 감춰두고, 1) 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 final 필드로 지정한다.
2) 정적 팩터리 메서드를 public static 멤버로 제공한다.   
* 24,25 싱글턴 클래스 직렬화 역직렬화 잘 모르겠음
3) 열거타입 방식의 싱글턴 - 바람직한 방법  

## ITEM4 인스턴스화를 막으려거든 private 생성자를 사용하라

## ITEM5
## ITEM6
## ITEM7 
## ITEM8
## ITEM9


## ?
* 불변클래스(immutable class; 아이템17)
* 인스턴스화 불가 (noninstantiable; 아이템4) : 
* 리플렉션(아이템 65)
* 24,25 싱글턴 클래스 직렬화 역직렬화 잘 모르겠음





