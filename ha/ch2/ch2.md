
# 객체 생성과 파괴
객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 법  
올바른 객체 생성 방법과 불필요한 생성을 피하는 방법  
제 때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령  

## ITEM1 생성자 대신 정적 팩터리 메서드를 고려하라
static factory method : 그 클래스의 인스턴스를 반환하는 단순한 static method  
* 장점
 * 생성자와는 달리 메서드 이름을 가질 수 있다. 객체의 특성을 제대로 설명할 수 있다.
 * 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불필요한 객체 생성을 피할 수 있다. 생성비용이 큰 객체가 자주 요청되는 상황이라면 성능이 좋아진다.
 * 반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. (? 다시읽자)
 * 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. (위에랑 똑같은소리 아닌가)
 * 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 
* 단점
 * 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
 * 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. API문서를 잘 써놓고 메서드 이름도 규약을 따라 지어라
 
## ITEM2 생성자에 매개변수가 많다면 빌더를 고려하라
정적 팩터리 메서드와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점이다.  
이럴 때 Builder pattern 을 이용하자.  
클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수 만으로 생성자를 호출해 빌더 객체를 얻는다. 그런다음 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정한다. 마지막으로 build 메서드를 호출해 객체를 얻는다.   
빌더와 세터 메서드들은 빌더 자신을 반환하기 때문에 method chaning 방식으로 호출 될 수 있다.  
ex) NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).build();  
빌더 패턴의 단점은, 빌더 생성비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다. 코드가 장황해져서 매개변수가 4개 이상은 되어야 값어치를 한다.

## ITEM3 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴(Singleton)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.  
싱글턴을 만드는 방식은 보통 두가지가 있다.  
생성자를 private로 감춰두고, 1) 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 final 필드로 지정한다.
2) 정적 팩터리 메서드를 public static 멤버로 제공한다. 3) 열거타입 방식의 싱글턴 - 바람직한 방법   
* 24,25 싱글턴 클래스 직렬화 역직렬화 잘 모르겠음

## ITEM4 인스턴스화를 막으려거든 private 생성자를 사용하라
private 생성자를 추가한다. 
추가적인 효과로 상속이 불가능해진다.


## ITEM5 자원을 직접 명시하지 말고 의존객체 주입을 사용하라
사용하는 자원에 따라 동작이 달라지는 클래스에서는 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주어 인스턴스를 생성하는것이 좋다.
* 팩터리 메서드 패턴 : 생성자에 자원팩터리를 넘겨주는 방식. 팩터리는 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체

클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 대신 필요한 자원을 Dependency Injection


## ITEM6 불필요한 객체 생성을 피하라
똑같은 기능의 객체를 매번 생성하지 말고 객체 하나를 재새용하는것이 빠른고 세련된다.
* String s = new String("abc") 대신 String s = "abc" 가 더 좋다.
* s.matchest("정규식") 에서 내부적으로 사용하는 Patten 인스턴스는 한 번 쓰고 버려져서 곧바고 GC 대상이 된다. 게다가 Pattern은 입력받은 값에 대한 유한상태머신(finite state machine)을 만들기 때문에 인스턴스 생성비용이 높다. 성능을 개선하려면 pattern 인스턴스를 static final 로 캐싱해두고 patternInstance.matcher(string).matches() 를 호출해 사용할 수 있다. (32p 예시 참고)
* 박싱된 기본타입(ex. Long, Integer) 보다는 기본타입(primitive type) 을 사용하자.

## ITEM7 다 쓴 객체 참조를 해제하라

## ITEM8
## ITEM9


## ?
* 불변클래스(immutable class; 아이템17)
* 인스턴스화 불가 (noninstantiable; 아이템4) : 
* 리플렉션(아이템 65)
* 24,25 싱글턴 클래스 직렬화 역직렬화 잘 모르겠음
* 유한상태머신(finite state machine)
* 오토 박싱



