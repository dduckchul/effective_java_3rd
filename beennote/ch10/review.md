# 10장 예외

## 아이템69 / 예외는 진짜 예외 상황에만 사용하라
* 예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.
* 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

## 아이템70 / 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
* 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
* 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

## 아이템71 / 필요 없는 검사 예외 사용은 피하라
* API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
* 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
* 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

## 아이템72 / 표준 예외를 사용하라

## 아이템73 / 추상화 수준에 맞는 예외를 던지라
* 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. = 예외 번역
* 무턱대고 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.
* 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.
* 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.

## 아이템74 / 메서드가 던지는 모든 예외를 문서화하라
* 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.
* 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.
