# 8장 메서드

## 아이템49 / 매개변수가 유효한지 검사하라

#### 메서드 매개변수
* 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.
* public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다(@throws 자바독 태그를 사용).
* 자바 7에 추가된 java.util.Objects.requireNonNull 메서드를 통해 더 이상 null 검사를 수동으로 하지 않아도 된다(예외 메세지 지정도 가능).
* public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다. -> 무조건 참이라고 선언한다.
* "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"

#### 생성자 매개변수
* "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다.

#### 메서드는 최대한 범용적으로
* 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다.

#### 핵심 정리
* 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각하라.
* 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다.

## 아이템50 / 적시에 방어적 복사본을 만들라
* 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
* 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 하고, 인스턴스 안에서는 원본이 아닌 복사본을 사용한다.
```java
// 생성자를 수정 - 여전히 Period 인스턴스는 변경 가능하다.
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());
  
  if(this.start.compareTo(this.end) > 0) {
    ...
  }
}

* 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목하자.
* 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다.
```
```java
// 접근자 - 완벽한 불변이다.
public Date start() {
  return new Date(start.getTime());
}

public Date end() {
  return new Date(end.getTime());
}

* 생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.
```

#### 핵심 정리
* 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
* 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사 대신 문서에 명시하도록 한다.

## 아이템51 / 메서드 시그니처를 신중히 설계하라
1. 메서드 이름을 신중히 짓자.
- 표준 명명 규칙을 따라야 한다. 자바 라이브러리의 API 가이드를 참조하면 좋다.
2. 편의 메서드를 너무 많이 만들지 말자.
- 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. 인터페이스도 마찬가지다.
3. 매개변수 목록은 짧게 유지하자.
- 4개 이하가 좋다. 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
- 1) 여러 메서드로 쪼갠다.
- 2) 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
- 3) 빌더 패턴을 메서드 호출에 응용한다.
4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.
5. boolean보다는 원소 2개짜리 열거 타입이 낫다.

## 아이템52 / 다중정의는 신중히 사용하라
* 어느 메서드를 호출할지는 컴파일 타임에 정해진다.
* 직관과 어긋나는 이유는 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된기 때문이다.
* 메서드를 하나로 합친 후 instanceof로 명시적으로 검사하면 해결된다.
* 매개변수 수가 같은 다중정의는 만들지 말자.
* 가변인수를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다.
* 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 열려 있다.
* 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다.

#### 핵심 정리
* 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 게 좋다.
* 상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있는데, 그럴 떄는 헷갈릴만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다.
* 그조차 불가능하면, 예켠데 기존 클래스를 수정해 새로운 인터페이스를 구현해야 할 때는 같은 객체를 입력받는 다중정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다.

## 아이템53 / 가변인수는 신중히 사용하라

#### 핵심 정리
* 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
* 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자. (가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화)

## 아이템54 / null이 아닌, 빈 컬렉션이나 배열을 반환하라

```java
// 빈 컬렉션을 반환하는 올바른 예
public List<Cheese> getCheeses() {
  return new ArrayList<>(cheesesInStock);
}

// 최적화 - 빈 컬렉션을 매번 새로 할당하지 않도록 했다.
// 매번 똑같은 빈 '불변'컬렉션을 반환한다.
public List<Cheese> getCheeses() {
  return cheesesInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheesesInStock);
}

// 길이가 0일 수도 있는 배열을 반환하는 올바른 방법
public Cheese[] getCheeses() {
  return cheesesInStock.toArray(new Cheese[0]);
}

// 최적화 - 빈 배열을 매번 새로 할당하지 않도록 했다.
private static final cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];

public Cheese[] getCheeses() {
  return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
}

// 나쁜 예 - 배열을 미리 할당하면 성능이 나빠진다.
return cheesesInStock.toArray(new Cheese[cheesesInStock.size()]);
```
#### 핵심 정리
* null이 아닌, 빈 배열이나 컬렉션을 반환하라.
* null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

## 아이템55 / 옵셔널 반환은 신중히 하라

#### 옵셔널
* 자바 8버전부터 Optional은 null이 아닌 T타입 참조를 하나 담거나, 혹은 아무것도 담지 않을 수 있다.
* 아무것도 담지 않은 옵셔널은 '비었다'고 말한다.
* 반대로 어떤 값을 담은 옵셔널은 '비지 않았다'고 한다.
* 옵셔널은 원소를 최대 1개 가질 수 있는 '불변' 컬렉션인데, Collection을 구현하지는 않았지만 원칙적으로는 그렇다.

#### 옵셔널 반환
* 빈 옵셔널은 Optional.empty() / 값이 든 옵셔널은 Optional.of(value) / null 값 허용 옵셔널은 Optional.ofNullable(value)
* 옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자.
* 옵셔널은 값이 업을 수도 있음을 API 사용자에게 명확히 알려준다. (검사 예외와 취지가 비슷)
* 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다.(기본값 정의 / 원하는 예외 던짐 / 항상 값이 채워져있다고 가정)
* 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.

#### 옵셔널을 선언해야 하는 기본 규칙
* 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 할 때.
* 성능이 중요한 상황에서는 옵셔널이 맞지 않을 수 있다.
* 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자. (기본 타입 전용 옵셔널이 준비되어 있음)
8 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없다.

#### 핵심 정리
* 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면 옵셔널을 반환해야 할 상황일 수 있다.
* 하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다.
* 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

## 아이템 56 / 공개된 API 요소에는 항상 문서화 주석을 작성하라
* 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.
* 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
* 한 클래스(혹은 인터페이스) 안에서 요약 설명이 똑같은 멤버(혹은 생성자)가 둘 이상이면 안 된다.
* 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
* 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
* 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.
* 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.
* 직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.
* 자바독 유틸리티가 생성한 웹페이지를 읽어보라.

#### 핵심 정리
* 공개 API라면 빠짐없이 설명을 달아야 한다.
* 표준 규약을 일관되게 지키자.
* 문서화 주석에 임의의 HTML 태그를 사용할 수 있음을 기억하라. 단, HTML 메타문자는 특별하게 취급해야 한다.


