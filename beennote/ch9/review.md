# 9장 일반적인 프로그래밍 원칙

## 아이템 57 / 지역변수의 범위를 최소화하라

* 지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'이다.
* 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
* 반복변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while 문보다는 for 문을 쓰는 편이 낫다.
* 메서드를 작게 유지하고 한가지 기능에 집중하는 것이다.

## 아이템 58 / 전통적인 for 문보다는 for-each 문을 사용하라

* for-each 문은 코드가 간결하면서도 성능은 똑같다.
* for-each 문을 사용할 수 없는 상황
1. 파괴적인 필터링: 컬렉션을 순회하면서 선택된 원소를 제거해야 하는 경우
2. 변형: 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체하는 경우
3. 병렬 반복: 여러 컬렉션을 병렬로 순회해야 하는 경우
* for-each 문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

#### 핵심 정리
* 전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해주며 성능 저하도 없다.

## 아이템 59 / 라이브러리를 익히고 사용하라

#### 라이브러리 사용의 장점
* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 다른 프로그래머들의 경험을 활용할 수 있다.
* 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
* 따로 노력하지 않아도 성능이 지속해서 개선된다.
* 기능이 점점 많아진다.
* 많은 사람에게 낯익은 코드가 된다.

* java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다.

#### 핵심 정리
* 코드 품질에 규모의 경제도 적용된다. 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.

## 아이템 60 / 정확한 답이 필요하다면 float와 double은 피하라

* float와 double 타입은 금융 관련 계산과는 맞지 않다. (과학과 공학 계산용으로 설계되어 '근사치'로 계산하도록 설계되었음)
* 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.
* BigDecimal의 생성자 중 문자열을 받는 생성자를 사용하여 계산시 부정확하나 값이 사용되는 걸 막는다.
* BigDecimal의 경우 기본 타입보다 쓰기가 훨씬 불편하고 훨씬 느리다는 단점이 있다.
* BigDeciaml 대신 int 혹은 long 타입을 쓰면 값의 크기가 제한되고 소수점을 직접 관리해야 한다.

#### 핵심 정리
* 코딩 시의 불편함이나 성능 저하를 신경 쓰지 않겠다면 BigDecimal을 사용하라.
* 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int(아홉 자리 십진수)나 long(열여덟 자리 십진수)을 사용하라.

## 아이템 61 / 박싱된 기본 타입보다는 기본 타입을 사용하라

#### 기본 타입과 박싱된 기본 타입의 주된 차이
* 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다. (reference)
* 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
* 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

#### 박싱된 기본 타입의 사용시 문제점
* 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.
* 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.

#### 박싱된 기본 타입은 언제 써야 하는가?
* 컬렉션의 원소, 키, 값으로 쓴다. -> 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
* 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

#### 핵심 정리
* 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.
* 오토박싱이 박싱도니 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.

## 아이템 62 / 다른 타입이 적절하다면 문자열 사용을 피하라

#### 문자열을 쓰지 않아야 할 사례
* 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
* 문자열은 열거 타입을 대신하기에 적합하지 않다.
* 문자열은 혼합 타입을 대신하기에 적합하지 않다.
* 문자열은 권한을 표현하기에 적합하지 않다.

#### 핵심 정리
* 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라.

## 아이템 63 / 문자열 연결은 느리니 주의하라

* 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n2에 비례한다.
* 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야하므로 성능 저하는 피할 수 없다.
* String 대신 StringBuilder를 사용하자.

## 아이템 64 / 객체는 인터페이스를 사용해 참조하라

* 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
* 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.
* 구현 클래스를 교체하고자 한다면 새 클래스의 생성자를 호출해주기만 하면 된다.

#### 적합한 인터페이스가 없는 케이스
* (String과 BigIntger) 같은 값 클래스
* (java.io 패키지의 클래스) 클래스 기반으로 작성된 프레임워크가 제공하는 객체들
* (PriorityQueue) 인터페이스에 없는 특별한 메서드를 제공하는 클래스
* 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자.

## 아이템 65 / 리플렉션보다는 인터페이스를 사용하라

#### 리플렉션 이용시 단점
* 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
* 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
* 성능이 떨어진다.

#### 리플렉션 이용
* 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.
* 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.
* 접근하려는 새로운 클래스나 메서드가 런타임에 존재하지 않을 수 있다는 사실을 반드시 감안하자.

## 아이템 66 / 네이티브 메서드는 신중히 사용하라

* 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다. JVM은 엄청난 속도로 발전해왔다.
* 네이티브 메서드는 메모리 훼손, 낮은 이식성, 어려운 디버깅, 성능 저하, 접착 코드 작성 필요 등의 단점이 존재한다.

## 아이템 67 / 최적화는 신중히 하라

* 빠른 프로그램보다는 좋은 프로그램을 작성하라.
* 성능을 제한하는 설계를 피하라. 완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
* API를 설계할 때 성능에 주는 영향을 고려하라.
* 잘 설계된 API는 성능도 좋은 게 보통이니 성능을 위해 API를 왜곡하는 건 매우 안좋은 생각이다.
* 자바는 작성하는 코드와 CPU에서 수행하는 명령 사이의 '추상화 격차'가 커서 최적화로 인한 성능 변화를 일정하게 예측하기가 어렵다.

## 아이템 68 / 일반적으로 통용되는 명명 규칙을 따르라

* 자바 언어 명세를 기준으로 표준 명명 규칙을 체화하여 자연스럽게 베어 나오도록 하자.
