# 6장 열거 타입과 애너테이션

## 아이템34 / int 상수 대신 열거 타입을 사용하라

#### 열거 타입
* 자바의 열거 타입은 완전한 형태의 클래스라서 (단순한 정숫값일 뿐인) 다른 언어의 열거 타입보다 훨씬 강력하다.
* 열거 타입 자체는 클래스이다.
* 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
* 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.
* 딱 하나씩만 존재함이 보장되므로 열거 타입은 인스턴스 통제된다.
* 열거 타입은 컴파일타임 타입 안전성을 제공한다.
* 이름이 같은 상수도 공존한다.
* 메서드나 필드를 추가할 수 있다.

#### 데이터와 메서드를 갖는 열거 타입
* 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
* 열거 타입은 근본적으로 불변이라 모든 필드는 final이어야 하고 private 으로 둔 뒤 별도의 public 접근자 메서드를 두는 게 낫다.

#### 열거 타입의 확장
* 열거 타입에서 상수를 하나 제거하면 제거하더라도 제거한 상수를 참조하지 않는 클라이언트에는 아무 영향이 없다.
* 상수별 메서드 구현이 가능하다.
* 열거 타입의 정적 필드 중 열거 타입의 생성자에서 접근할 수 있는 것은 상수 변수뿐이다.
* 열거 타입 생성자가 실행되는 시점에는 정적 필드들이 아직 초기화되기 전이라, 자기 자신을 추가하지 못하게 하는 제약이 필요하다.
* 열거 타입 생성자에서 같은 열거 타입의 다른 상수에도 접근할 수 없다.
* switch 문은 열거 타입의 상수별 동작을 구현하는 데 적합하지 않지만, 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수 있다.

#### 열거 타입의 사용 시점
* 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
* 열거 타입에 정의된 상수 개수가 영원히 고정불변일 필요는 없다.

#### 핵심 정리
* 열거 타입은 정수 상수보다 뛰어나다.
* 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때는 명시적 생성자나 메서드가 필요하다.
* 하나의 메서드가 상수별로 다르게 동작해야할 때도 있다.
* switch문 대신 상수별 메서드 구현을 사용하고 열거 타입 상수 일부가 같은 동작을 공유할 경우, 전략 열거 타입 패턴을 사용하자.

## 아이템35 / ordinal 메서드 대신 인스턴스 필드를 사용하라.

#### ordinal 메서드
* 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.
* 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고 인스턴스 필드에 저장하는 게 좋다. 사용x

## 아이템36 / 비트 필드 대신 EnumSet을 사용하라

#### 비트 필드
* 비트별 OR를 사용해 여러 상수를 하나의 집합으로 모을 수 있으며, 이렇게 만들어진 집합을 비트 필드라 한다.
* 비트 필드는 정수 열거 상수의 단점을 그대로 지니며 추가적인 문제까지 안고 있다.

#### EnumSet
* java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.
* Set 인터페이스를 완벽히 구현하며, 타입 안전하고, 다른 어떤 Set 구현체와도 함께 사용할 수 있다.

```java
EnumSet - 비트 필드를 대체하는 현대적 기법
public class Text {
  public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }
  
  // 어떤 Set을 넘겨도 되나, EnumSet이 가장 좋다.
  public void applyStyles(Set<Style> styles) {...}
}

//EnumSet 인스턴스를 건네는 클라이언트 코드.
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

#### 핵심 정리
* 열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없다.
* 자바 9까지는 불변 EnumSet을 만들 수 없으니 (명확성과 성능이 조금 희생되지만) Collections.unmodifiableSet으로 EnumSet을 감싸 사용할 수 있다.

## 아이템37 / ordinal 인덱싱 대신 EnumMap을 사용하라

#### ordinal 인덱싱
* 여러가지 문제가 있지만 그 중에서도 가장 심각한 문제는 정확한 정숫값을 사용한다는 것을 직접 보증해야 한다는 점이다.
* 정수는 열거 타입과 달리 타입 안전하지 않다.

#### EnumMap
* EnumMap의 성능이 ordinal을 쓴 배열에 비견되는 이유는 그 내부에서 배열을 사용하기 때문이다. 내부 구현 방식을 안으로 숨겨서 Map의 타입 안전성과 배열의 성능을 모두 얻어낸다.

#### 핵심정리
* 배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.
* 다차원 관계는 EnumMap<..., EnumNap<...>>으로 표현하라.

## 아이템38 / 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

#### 열거 타입의 확장
* 대부분 상황에서 열거 타입을 확장하는 건 좋지 않은 생각.
* 연산 코드 같은 경우 사용자 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있다.
* 인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게 한다.
* 인터페이스를 사용하도록 작성되어 있기만 하면 새로 작성한 연산은 기존 연산을 쓰던 곳 어디든 쓸 수 있다.
* 개별 인스턴스 수준에서뿐 아니라 타입 수준에서도 기본 열거 타입 대신 확장된 열거 타입을 넘겨 확장된 열거 타입의 원소 모두를 사용하게 할 수도 있다.
* 열거 타입끼리 구현을 상속할 수 없다는 한가지 사소한 문제가 있다.

#### 핵심 정리
* 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.
* 인터페이스 기반으로 작성되었다면 기본 열거 타입의 인스턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.
