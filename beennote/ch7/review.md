# 람다와 스트림

## 아이템42 / 익명 클래스보다는 람다를 사용하라

#### 람다의 사용
* 추상 메서드 하나짜리 인터페이스는 함수형 인터페이스라 부르는 인터페이스들의 인스턴스를 람다식을 사용해 만들 수 있게 됐다. 자바 8부터.
* 컴파일러가 문맥을 통해 매개변수, 반환값 타입등을 추론한다.
* 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.
* 컴파일러가 타입을 추론하는 데 필요한 타입 정보 대부분을 제네릭에서 얻는다.
* 람다는 이름이 없고 문서화도 못한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다. (세 줄 안에 끝내는게 좋다)

#### 람다를 사용하지 못하는 경우
* 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니 익명 클래스를 써야 한다.
* 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
* 람다는 자신을 참조할 수 없으므로 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.
* 람다를 직렬화하는 일은 극히 삼가야 한다.

## 아이템43 / 람다보다는 메서드 참조를 사용하라
* 메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.
1. 정적: Integer::parseInt / str -> Integer.parseInt(str)
2. 한정적(인스턴스): instant.now()::isAfter / Instant then = Instant.now(); t-> then.isAfter(t)
3. 비한정적(인스턴스): String::toLowerCase / str -> str.toLowerCase()
4. 클래스 생성자: TreeMap<K,V>::new / () -> new TreeMap<K,V>()
5. 배열 생성자: int[]::new / len -> new int[len]

## 아이템44 / 표준 함수형 인터페이스를 사용하라
* 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.
* 보통은 java.util.funtion 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.
* 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 경우 항상 @FunctionalInterface 애너테이션을 사용하라.
