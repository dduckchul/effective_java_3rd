# 클래스와 인터페이스

## 아이템15 / 클래스와 멤버의 접근 권한을 최소화하라

* 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 정보 은닉, 혹은 캡슐화이다.
* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 접근 제한자
1. private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
2. package-private: 멤버가 소속된 패키지 안의 모든 클래스에 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다(단, 인터페이스의 멤버는 기본적으로 public이 적용된다).
3. protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
4. public: 모든 곳에서 접근할 수 있다.
* 최대한 private으로 만들자.
* 상위 클래스의 메서드를 재정의 할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다(제약).
* public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
* 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

#### 핵심 정리
프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자.

## 아이템16 / public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

* public 클래스: 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공하여 유연성을 얻어라.
* package-private 클래스/private 중첩 클래스: 데이터 필드를 노출한다 해도 문제가 없다.

#### 핵심 정리
public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 불변 필드라도 완전히 안심할 수 없다.

## 아이템17 / 변경 가능성을 최소화하라

* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
* 클래스를 불변으로 만드는 다섯 가지 규칙
1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다
* 함수형 프로그래밍: 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴(plus 같은 전시차 사용)
* 절차적/명령형 프로그래밍: 피연산자인 자신을 수정해 자신의 상태가 변하는 프로그래밍 패(add 같은 동사 사용)

#### 불변 클래스의 장단점
* 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다(안심하고 공유가 가능).
* 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
* 객체를 만들 때 다른 불변 객체들을 구성요소라 사용하면 이점이 있다(불변 객체는 맵의 키와 집합의 원소로 쓰기에 안성맞춤).
* 불변 객체는 그 자체로 실패 원자성(메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질)을 제공한다.
* 불변 클래스의 단점은 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.

#### 불변 클래스 설계
* 필드를 private final, 생성자를 private 혹은 package-private, public 정적 팩터리 제공 / 이 방법이 불변 클래스 설계의 최선일 때가 많다.
* 클래스는 꼭 필요한 경우가 아니라면 불변이어야 하고 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야ㅕㅑ 한다.
* 별다른 이유가 없다면 모든 필드는 private final이어야 한다.
* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
* 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
* 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다.

## 아이템18 / 상속보다는 컴포지션을 사용하라

#### 상속의 단점
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.

#### 컴포지션
* 컴포지션(has a 관계): 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방식.
* 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다(전달: forwarding).
* 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
* 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.
* 래퍼 클래스 / 전달 클래스

#### 상속 vs 컴포지션 결정
* is-a 관계인가?
* 컴포지션을 써야 할 상황에서 상속을 사용하면 클라이언트가 노출된 내부에 직접 접근할 수 있다.
* 확작하려는 클래스의 API에 아무런 결함이 있는지 확인해야 한다. 상속은 결함도 승계하기 때문이다.

#### 핵심 정리
상속은 캡슐화를 해친다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.

## 아이템19 / 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
* 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
* 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다. 반드시 검증 필요.
* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

#### 상속을 금지하는 방법
* 둘 중 더 쉬운 쪽은 클래스를 final로 선언한다.
* 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어준다.

#### 핵심 정리
상속용 클래스는 모두 문서로 남기고 문서화 한 것은 반드시 지켜야 한다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.

## 아이템20 / 추상 클래스보다는 인터페이스를 우선하라

#### 인터페이스와 추상 클래스
* 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다. 새로운 타입을 정의하는데 커다란 제약.
* 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급한다.

#### 인터페이스의 특징
* 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
* 인터페이스는 믹스인(mixin: 대상 타입의 주된 기능에 선택적 기능을 '혼합') 정의에 안성맞춤이다.
* 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다. 조합 폭발 현상을 피할 수 있음.
* 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
1. 추상 골격 구현: 인터페이스로는 타입을 정의하고(필요하면 디폴트 메서드 제공) 골격 구현 클래스는 나머지 메서드들까지 구현한다. 그러면 골격 구현 클래스만 확장하면 인터페이스를 구현하는데 필요한 일이 대부분 완료된다.(템플릿 메서드 패턴)
2. 골격 구현 클래스는 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다.

#### 핵심 정리
일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자.

## 아이템21 / 인터페이스는 구현하는 쪽을 생각해 설계하라

* 인터페이스를 설계 할 때는 여전히 세심한 주의를 기울여야 한다.
* 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만 절대 그 가능성에 기대서는 안된다.

## 아이템22 / 인터페이스는 타입을 정의하는 용도로만 사용하라

* 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.

## 아이템23 / 태그 달린 클래스보다는 클래스 계층구조를 활용하라

#### 태그 달린 클래스의 단점
* 장황하고, 오류를 내기 쉽고, 비효율적이다.
* 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다.

#### 핵심 정리
태그를 없애고 계층구조로 대체하는 방법을 생각해보자.

## 아이템24 / 멤버 클래스는 되도록 static으로 만들라

#### 중첩 클래스
* 중첩 클래스: 다른 클래스 안에 정의된 클래스
* 중첩 클래스의 종류: 정적 멤버 클래스, (비정적) 멤버 클래스, 익명 클래스, 지역 클래스

#### 정적 멤버 클래스
* 바깥 클래스의 private 멤버에도 접근 가능
* 다른 정적 멤버와 똑같은 접근 규칙을 적용받는다.
* 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다. 

#### 비정적 멤버 클래스
* 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
* 정규화된 this(클래스명.this)를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
* 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문에 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다.
* 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며 더이상 변경할 수 없다.
* 어댑터(어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰)를 정의할 때 자주 쓰인다.

#### 익명 클래스
* 익명 클래스는 바깥 클래스의 멤버가 아니다.
* 사용하는 순간에 선언하고 객체를 만든다.
* 비-정적 문맥(nonstatic context) 안에서 사용될 때만 바깥 객체를 갖는다
* 정적 문맥(static context) 안에서 사용된다 해도 static 멤버를 가질 수 없다.

#### 지역 클래스
* 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있고 유효 범위도 지역변수와 같다.
* 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다.
* 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있다.
* 정적 멤버는 가질 수 없으며 가독성을 위해 짧게 작성해야 한다.

#### 핵심 정리
* 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다.
* 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로 만들자.
* 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이가 이미 있다면 익명 클래스로 만들자.
* 그렇지 않으면 지역 클래스로 만들자.

## 아이템25 / 톱레벨 클래스는 한 파일에 하나만 담으라

* 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자.
* 컴파일러가 한 클래스에 대한 정의를 여러 개 만들어내는 일은 사라진다.
