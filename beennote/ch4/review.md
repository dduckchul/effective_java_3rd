# 클래스와 인터페이스

## 아이템15 / 클래스와 멤버의 접근 권한을 최소화하라

* 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 정보 은닉, 혹은 캡슐화이다.
* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 접근 제한자
1. private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
2. package-private: 멤버가 소속된 패키지 안의 모든 클래스에 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다(단, 인터페이스의 멤버는 기본적으로 public이 적용된다).
3. protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
4. public: 모든 곳에서 접근할 수 있다.
* 최대한 private으로 만들자.
* 상위 클래스의 메서드를 재정의 할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다(제약).
* public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
* 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

#### 핵심 정리
프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자.

## 아이템16 / public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

* public 클래스: 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공하여 유연성을 얻어라.
* package-private 클래스/private 중첩 클래스: 데이터 필드를 노출한다 해도 문제가 없다.

#### 핵심 정리
public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 불변 필드라도 완전히 안심할 수 없다.

## 아이템17 / 변경 가능성을 최소화하라

* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
* 클래스를 불변으로 만드는 다섯 가지 규칙
1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다
* 함수형 프로그래밍: 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴(plus 같은 전시차 사용)
* 절차적/명령형 프로그래밍: 피연산자인 자신을 수정해 자신의 상태가 변하는 프로그래밍 패(add 같은 동사 사용)

#### 불변 클래스의 장단점
* 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다(안심하고 공유가 가능).
* 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
* 객체를 만들 때 다른 불변 객체들을 구성요소라 사용하면 이점이 있다(불변 객체는 맵의 키와 집합의 원소로 쓰기에 안성맞춤).
* 불변 객체는 그 자체로 실패 원자성(메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질)을 제공한다.
* 불변 클래스의 단점은 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.

#### 불변 클래스 설계
* 필드를 private final, 생성자를 private 혹은 package-private, public 정적 팩터리 제공 / 이 방법이 불변 클래스 설계의 최선일 때가 많다.
* 클래스는 꼭 필요한 경우가 아니라면 불변이어야 하고 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야ㅕㅑ 한다.
* 별다른 이유가 없다면 모든 필드는 private final이어야 한다.
* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
* 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
* 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다.

## 아이템18 / 상속보다는 컴포지션을 사용하라

#### 상속의 단점
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.

#### 컴포지션
* 컴포지션(has a 관계): 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방식.
* 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다(전달: forwarding).
* 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
* 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.
* 래퍼 클래스 / 전달 클래스

#### 상속 vs 컴포지션 결정
* is-a 관계인가?
* 컴포지션을 써야 할 상황에서 상속을 사용하면 클라이언트가 노출된 내부에 직접 접근할 수 있다.
* 확작하려는 클래스의 API에 아무런 결함이 있는지 확인해야 한다. 상속은 결함도 승계하기 때문이다.

#### 핵심 정리
상속은 캡슐화를 해친다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.

## 아이템19 / 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
* 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
* 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다. 반드시 검증 필요.
* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

#### 상속을 금지하는 방법
* 둘 중 더 쉬운 쪽은 클래스를 final로 선언한다.
* 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어준다.

#### 핵심 정리
상속용 클래스는 모두 문서로 남기고 문서화 한 것은 반드시 지켜야 한다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.
